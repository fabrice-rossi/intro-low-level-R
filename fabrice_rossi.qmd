---
title: "Introduction to Low Level R"
author: "Fabrice Rossi"
format: html
---

## Types and classes
### Types
```{r}
typeof(1.5)
typeof("toto")
typeof('also between single quotes')
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```

### Classes

```{r}
data(iris)
typeof(iris)
class(iris)
```

## Vectors
### Introduction
Many things in R are vectors (and most of the other things are lists).

A vector is a collection of values of the same type (possibly a single value).

```{r}
x <- 15.25
length(x) ## all vectors have a length
x[1]
```

```{r}
length(length(x))
typeof(length(x))
```

The `c` function can be seen as a creation function or, more accurately, as a
vector concatenation function. 

```{r}
y <- c(1, -2, 45, 1.5, -1e-5)
y
typeof(y)
y[2]
length(y)
```

```{r}
c(x, y)
```

### Character vectors

This is not R strength...

```{r}
z <- "Alice"
length(z)
```

Salvation comes from the `stringr` package. 

```{r}
library(stringr)
```

```{r}
str_length(z)
```

```{r}
complicated <- "ðŸ˜µ ðŸ˜¡ ðŸ˜  ðŸ¤¬ Ræ˜¯ä¸€é—¨å¾ˆå¥½çš„ç¼–ç¨‹è¯­è¨€ Ù‡ÙŠ Ù„ØºØ© Ø¨Ø±Ù…Ø¬Ø© Ø±Ø§Ø¦Ø¹Ø©"
complicated
length(complicated)
str_length(complicated)
```

```{r}
some_values <- c("ðŸ˜µ ðŸ˜¡ ðŸ˜  ðŸ¤¬", "Ræ˜¯ä¸€é—¨å¾ˆå¥½çš„ç¼–ç¨‹è¯­è¨€", "alice")
some_values
length(some_values)
str_length(some_values)
str_to_upper(some_values)
```

### Indexing

```{r}
x <- c(6, 5, 1, 2, 3, 4)
x[3]
```

```{r}
x[4] <- 15
x
```

Assignment can be understood has a value semantic assignment: `x` and `y` are
different vectors with the same initial content.

```{r}
y <- x
y
```

Therefore, modifying `x` has no effect on `y`.

```{r}
x[1] <- 18
x
y
```

Indexing is made with vectors of any length.

```{r}
x
x[c(2, 2, 1, 4, 3)]
```

```{r}
x[0] ## no possible meaning -> empty numeric vector
x[7] ## no value there -> not available
x[10]
```

```{r}
typeof(numeric(0))
length(numeric(0))
```

```{r}
typeof(NA)
length(NA)
```

```{r}
typeof(NA_integer_)
NA_integer_
```

```{r}
x
x[c(4, 1, 0, 15)]
```

```{r}
c(numeric(0), 5, numeric(0))
```

```{r}
x
x[c(-1, -4, -12)]
```


```{r}
x
x[c(1, 4)] <- c(-34, 42)
x
x[c(2, 10)] <- c(123, 78)
x
```

```{r}
y <- c("A", "B", "C")
y
y[c(TRUE, FALSE, TRUE)]
```

## Lists

Vectors must be type uniform, which will trigger a conversion to character in
many cases. 

```{r}
broken <- c(1L, 1.5, "toto", FALSE)
broken
typeof(broken)
```

Lists do not have this limitation.

### Creating a list

```{r}
bar <- list(1L, 1.5, "toto", FALSE)
bar
```

```{r}
typeof(bar)
length(bar)
```

A list can be understood as a vector of "vectors". 

```{r}
foo <- list(c(1, 2, 3), TRUE, length)
foo
length(foo)
```

### Indexing

```{r}
foo
cat("###\n")
foo[1]
cat("###\n")
foo[-2]
cat("###\n")
foo[c(3, 2, 2, 1)]
```
```{r}
foo[0]
foo[4]
```

### Side step: weird values
```{r}
NA ## missing value
NULL ## missing object
NaN ## Not a number
```

```{r}
0/0
1/0
-1/0
1/0 - 1/0
1/0 + 1
1/0 - 10e10
1/Inf
```

```{r}
NA_real_ + 1
1/NA_real_
```

```{r}
NULL + 1
```

### Back to indexing lists
```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x
```

```{r}
x[c(1,4,5)]
```
```{r}
x[5] <- list(c(-2, 1))
x
```

```{r}
y <- c(1, 2, 3)
y
y[4] <- "toto"
y
```

```{r}
class(x)
class(x[1])
```

The indexing operation `[]` does not change the type or the class of the 
corresponding object. 

### Double brackets

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[1] ## single
x[[1]] ## double
```
```{r}
x[2] <- c("toto", "bar")
x
```

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[[2]] <- c("toto", "bar")
x[[4]] <- 1:15 ## sequence of integers from 1 to 15
x
```

```{r}
x[[c(1, 2)]]
x[[c(3, 2)]]
```

```{r}
y <- list(1:4, list(letters[1:5], list(c("foo", "bar"))))
y
y[[2]]
y[[c(2, 1)]]
y[[c(2, 2, 1, 2)]]
y[[2]][[2]][[1]][2]
```
### Names
```{r}
z <- list(keys = c("A", "B", "C"), values = c(10, 11, 12), key =c(TRUE, FALSE))
z
z[[1]]
z$keys ## a named access with the dollar operator is similar to the double bracket
z$val ## funny but dangerous name completion
z$key
z$ke
z[["keys"]]
z[["val"]] ## exact matching only
z["values"]
z["values"] |> class()
z[["values"]] |> class()
```

Remark: a data frame is a list in which each element (each column) has the same
length. 

```{r}
names(z)
```

```{r}
names(z) <- c("A", "B", "C")
z
```

## Functions

R extensions (packages) consist essentially in collections of functions. 

A function is an object that can be called by adding parentheses after the 
function name, and possibly parameters inside the parentheses (effective
parameters).

```{r}
names
```

```{r}
log
```

In R functions can have multiple formal parameters and some of them may have
default values. When a function is called, one has to specify in general at least
values for the parameters without a default value.

```{r}
log(10) ## base takes the default value (e)
log(10, 10) ## now base=10
```

```{r}
seq.int
```
```{r}
seq.int(1, 10) ## by is set to 1
seq.int(10, 1) ## by is set to -1
```

### Creating functions

This is done with the `function` key word.

```{r}
my_fun <- function(x, y) { ## between parentheses, we specify the formal parameters
  ## between the curly braces {} we describe the operations implemented by 
  ## the function
  2*abs(x-y)/(abs(x)+abs(y)+1e-15)
}
```

```{r}
my_fun
functionBody(my_fun)
```

```{r}
#| eval: false
my_fun() ## cannot work: x and y are missing
```

```{r}
my_fun(2, 1)
my_fun(2, 2)
my_fun(0, 0)
```

Function execution is essentially running the code inside the body of the function
after replacing the formal parameters by the values used as effective parameters
at the call point. The value of the call is the last value computed in the 
function.

```{r}
my_fun(4, 1) # x takes the value 4, and y takes the value 1
```

```{r}
my_second_fun <- function(x, y) {
  z <- x + y 
  z/y
  z/x
}
```

```{r}
my_second_fun(1, 2)
```

A variable defined in a function is private to the function. It does not care
about existing variables with the same name and it disappears just before the
end of the function execution. 

```{r}
z <- 10
my_second_fun(1, 2)
z 
```

### Default parameters and call by name

To specify a default value for a parameter, we add a equal sign `=` after
the formal parameter name followed by the default value. 

```{r}
x_to_y <- function(x, y=2) {
  x^y
}
```

```{r}
x_to_y(2, 3)
x_to_y(10)
```

Standard calls use positional effective parameters: all effective parameters are 
specified in the order of the formal parameters. 

This can be combined with named effective parameters: the name of the format
parameter is used in the call, followed by an equal sign and the chosen value. 
In this case, order does not matter any more. 

```{r}
x_to_y(y = 4, x = 2) ## 2^4
```

Positions and names can be combined if all names are after the unnamed 
parameters. 


