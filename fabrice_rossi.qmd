---
title: "Introduction to Low Level R"
author: "Fabrice Rossi"
format: html
---

## Types and classes
### Types
```{r}
typeof(1.5)
typeof("toto")
typeof('also between single quotes')
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```

### Classes

```{r}
data(iris)
typeof(iris)
class(iris)
```

## Vectors
### Introduction
Many things in R are vectors (and most of the other things are lists).

A vector is a collection of values of the same type (possibly a single value).

```{r}
x <- 15.25
length(x) ## all vectors have a length
x[1]
```

```{r}
length(length(x))
typeof(length(x))
```

The `c` function can be seen as a creation function or, more accurately, as a
vector concatenation function. 

```{r}
y <- c(1, -2, 45, 1.5, -1e-5)
y
typeof(y)
y[2]
length(y)
```

```{r}
c(x, y)
```

### Character vectors

This is not R strength...

```{r}
z <- "Alice"
length(z)
```

Salvation comes from the `stringr` package. 

```{r}
library(stringr)
```

```{r}
str_length(z)
```

```{r}
complicated <- "ðŸ˜µ ðŸ˜¡ ðŸ˜  ðŸ¤¬ Ræ˜¯ä¸€é—¨å¾ˆå¥½çš„ç¼–ç¨‹è¯­è¨€ Ù‡ÙŠ Ù„ØºØ© Ø¨Ø±Ù…Ø¬Ø© Ø±Ø§Ø¦Ø¹Ø©"
complicated
length(complicated)
str_length(complicated)
```

```{r}
some_values <- c("ðŸ˜µ ðŸ˜¡ ðŸ˜  ðŸ¤¬", "Ræ˜¯ä¸€é—¨å¾ˆå¥½çš„ç¼–ç¨‹è¯­è¨€", "alice")
some_values
length(some_values)
str_length(some_values)
str_to_upper(some_values)
```

### Indexing

```{r}
x <- c(6, 5, 1, 2, 3, 4)
x[3]
```

```{r}
x[4] <- 15
x
```

Assignment can be understood has a value semantic assignment: `x` and `y` are
different vectors with the same initial content.

```{r}
y <- x
y
```

Therefore, modifying `x` has no effect on `y`.

```{r}
x[1] <- 18
x
y
```

Indexing is made with vectors of any length.

```{r}
x
x[c(2, 2, 1, 4, 3)]
```

```{r}
x[0] ## no possible meaning -> empty numeric vector
x[7] ## no value there -> not available
x[10]
```

```{r}
typeof(numeric(0))
length(numeric(0))
```

```{r}
typeof(NA)
length(NA)
```

```{r}
typeof(NA_integer_)
NA_integer_
```

```{r}
x
x[c(4, 1, 0, 15)]
```

```{r}
c(numeric(0), 5, numeric(0))
```

```{r}
x
x[c(-1, -4, -12)]
```


```{r}
x
x[c(1, 4)] <- c(-34, 42)
x
x[c(2, 10)] <- c(123, 78)
x
```

```{r}
y <- c("A", "B", "C")
y
y[c(TRUE, FALSE, TRUE)]
```

### Vector "interpolation" (broadcasting)

Why is that working?

```{r}
x <- c(1, 2, 3)
x + 1
```

Most operations in R are vectorized: the same operation is applied by default
to all the elements of a vector. To ease that, vectors can be expanded to match
a certain length, simply by copying the values of the vector a certain number 
of times. For instance `1` can be interpreted as `c(1, 1, 1)` if this is
needed for a combination with a length 3 vector (as above). 

```{r}
x >= 2
```

```{r}
set.seed(42) ## ensure reproducibility by starting the random number generator in 
## state 42 (any integer works)
x <- runif(20, min = -1, max = 1) ## uniform distribution
sum(x > 0)
sum(x > mean(x))
x[x <= mean(x)]
length(x[ x > mean(x)])
```

```{r}
u <- c(1, 2, 3)
v <- c(4, 5) ## if we duplicate v, we are left with an unused value
u + v
```

```{r}
u <- c(1, 2, 3, 4)
v <- c(-1, 1) ## here we just need to duplicate v
u + v
u * v
```

### if else
We want to compute the Shannon's entropy of a distribution: 
$$
H(p)=-\sum_{k=1}^Kp_k\log p_k,
$$
where $p_k$ is the probability of observing $k$. A possible naive definition is
the following one (see functions below):

```{r}
H <- function(p) {
  -sum(p*log(p))
}
```

```{r}
rep(1, 10) ## replicate 1 10 times
rep(1, 10)/10 ## uniform probability distribution over 1 to 10
H(rep(1, 10)/10)
```

```{r}
my_dist <- c(0, 0.5, 0.5) ## distribution over 1, 2 and 3
H(my_dist)
0*log(0) ## undefined
```

The natural convention in entropy calculation is that $p_k\log(p_k)=0$ when 
$p_k=0$. We can use `ifelse` to implement that.

```{r}
working_H <- function(p) {
  p_logp <- ifelse(p>0, p*log(p), 0) ## for elements of p that > 0, we use the 
  ## formula (second parameter of ifelse) and we use 0 for the others (third
  ## parameter)
  -sum(p_logp)
}
```

```{r}
working_H(my_dist)
working_H(rep(1, 3)/3)
working_H(c(1, 0, 0))
```


## Lists

Vectors must be type uniform, which will trigger a conversion to character in
many cases. 

```{r}
broken <- c(1L, 1.5, "toto", FALSE)
broken
typeof(broken)
```

Lists do not have this limitation.

### Creating a list

```{r}
bar <- list(1L, 1.5, "toto", FALSE)
bar
```

```{r}
typeof(bar)
length(bar)
```

A list can be understood as a vector of "vectors". 

```{r}
foo <- list(c(1, 2, 3), TRUE, length)
foo
length(foo)
```

### Indexing

```{r}
foo
cat("###\n")
foo[1]
cat("###\n")
foo[-2]
cat("###\n")
foo[c(3, 2, 2, 1)]
```
```{r}
foo[0]
foo[4]
```

### Side step: weird values
```{r}
NA ## missing value
NULL ## missing object
NaN ## Not a number
```

```{r}
0/0
1/0
-1/0
1/0 - 1/0
1/0 + 1
1/0 - 10e10
1/Inf
```

```{r}
NA_real_ + 1
1/NA_real_
```

```{r}
NULL + 1
```

### Back to indexing lists
```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x
```

```{r}
x[c(1,4,5)]
```
```{r}
x[5] <- list(c(-2, 1))
x
```

```{r}
y <- c(1, 2, 3)
y
y[4] <- "toto"
y
```

```{r}
class(x)
class(x[1])
```

The indexing operation `[]` does not change the type or the class of the 
corresponding object. 

### Double brackets

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[1] ## single
x[[1]] ## double
```
```{r}
x[2] <- c("toto", "bar")
x
```

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[[2]] <- c("toto", "bar")
x[[4]] <- 1:15 ## sequence of integers from 1 to 15
x
```

```{r}
x[[c(1, 2)]]
x[[c(3, 2)]]
```

```{r}
y <- list(1:4, list(letters[1:5], list(c("foo", "bar"))))
y
y[[2]]
y[[c(2, 1)]]
y[[c(2, 2, 1, 2)]]
y[[2]][[2]][[1]][2]
```
### Names
```{r}
z <- list(keys = c("A", "B", "C"), values = c(10, 11, 12), key =c(TRUE, FALSE))
z
z[[1]]
z$keys ## a named access with the dollar operator is similar to the double bracket
z$val ## funny but dangerous name completion
z$key
z$ke
z[["keys"]]
z[["val"]] ## exact matching only
z["values"]
z["values"] |> class()
z[["values"]] |> class()
```

Remark: a data frame is a list in which each element (each column) has the same
length. 

```{r}
names(z)
```

```{r}
names(z) <- c("A", "B", "C")
z
```

## Functions

R extensions (packages) consist essentially in collections of functions. 

A function is an object that can be called by adding parentheses after the 
function name, and possibly parameters inside the parentheses (effective
parameters).

```{r}
names
```

```{r}
log
```

In R functions can have multiple formal parameters and some of them may have
default values. When a function is called, one has to specify in general at least
values for the parameters without a default value.

```{r}
log(10) ## base takes the default value (e)
log(10, 10) ## now base=10
```

```{r}
seq.int
```
```{r}
seq.int(1, 10) ## by is set to 1
seq.int(10, 1) ## by is set to -1
```

### Creating functions

This is done with the `function` key word.

```{r}
my_fun <- function(x, y) { ## between parentheses, we specify the formal parameters
  ## between the curly braces {} we describe the operations implemented by 
  ## the function
  2*abs(x-y)/(abs(x)+abs(y)+1e-15)
}
```

```{r}
my_fun
functionBody(my_fun)
```

```{r}
#| eval: false
my_fun() ## cannot work: x and y are missing
```

```{r}
my_fun(2, 1)
my_fun(2, 2)
my_fun(0, 0)
```

Function execution is essentially running the code inside the body of the function
after replacing the formal parameters by the values used as effective parameters
at the call point. The value of the call is the last value computed in the 
function.

```{r}
my_fun(4, 1) # x takes the value 4, and y takes the value 1
```

```{r}
my_second_fun <- function(x, y) {
  z <- x + y 
  z/y
  z/x
}
```

```{r}
my_second_fun(1, 2)
```

A variable defined in a function is private to the function. It does not care
about existing variables with the same name and it disappears just before the
end of the function execution. 

```{r}
z <- 10
my_second_fun(1, 2)
z 
```

### Default parameters and call by name

To specify a default value for a parameter, we add a equal sign `=` after
the formal parameter name followed by the default value. 

```{r}
x_to_y <- function(x, y=2) {
  x^y
}
```

```{r}
x_to_y(2, 3)
x_to_y(10)
```

Standard calls use positional effective parameters: all effective parameters are 
specified in the order of the formal parameters. 

This can be combined with named effective parameters: the name of the format
parameter is used in the call, followed by an equal sign and the chosen value. 
In this case, order does not matter any more. 

```{r}
x_to_y(y = 4, x = 2) ## 2^4
```

Positions and names can be combined if all names are after the unnamed 
parameters. 

### Functions are objects

R has some features of functional languages. 

```{r}
all_my_funs <- list(f1 = my_fun, f2=my_second_fun, f3=x_to_y)
all_my_funs
```

```{r}
all_my_funs[["f3"]](10, 5.5)
```

```{r}
x <- list(1:3, letters[10:20])
x
```
`lapply` applies a function to each of the elements of a list and returns a list
made with the results. 

```{r}
lapply(x, length)
```

This works also on a vector (the result is still a list).

```{r}
lapply(1:10, x_to_y)
```

`sapply` tries to simplify the resulting list into a vector (or an array) if the 
content of the list has a single type.

```{r}
sapply(x, length)
sapply(1:10, x_to_y)
```

```{r}
#| eval: false
res <- lapply(X, f, toto=2, z=32) ## ???
res[[i]] <- f(X[[i]], toto=2, z=32)
```

Here each call to `x_to_y` has a first effective parameter taken in the 
vector `1:10` and a second named parameter `y = 3`.

```{r}
sapply(1:10, x_to_y, y = 3)
```

```{r}
my_data <- list(x = 1:10,
                y = c(NA, 2:5, NA, 6:20))
my_data
```

```{r}
lapply(my_data, mean)
```

In this version, the parameter `na.rm` is set to `TRUE` in all the mean
calculations.

```{r}
lapply(my_data, mean, na.rm = TRUE)
```

### Anonymous functions a.k.a. lambdas

Compact function declaration (can be used directly as parameters). 

```{r}
\(x) x^2
```

```{r}
log(1:10, base = 10)
```

A complicated way of doing something simple:

```{r}
sapply(1:10, \(x,y) 1+y*log(x), y=2)
```

```{r}
1+2*log(1:10)
```


```{r}
my_data <- list(x = 1:10,
                y = c(NA, 2:5, NA, 6:20))
lapply(my_data, mean, na.rm=TRUE)
lapply(my_data, \(x) mean(x, na.rm=TRUE))
lapply(my_data, \(x) 1+2*log(x))
```

### Closure

```{r}
power_function <- function(y) {
  \(x) x^y ## closure: a function + some values
}
to_the_cube <- power_function(3)
to_the_cube(1:10)
to_the_cube
\(x, y) x^y
power_function(4)(4)
to_the_cube(2)
```

```{r}
x_to_y <- function(x, y) {
  x^y
}
f <- \(x) x_to_y(x, 2)
f(5)
f
```

```{r}
z <- 3
g <- \(x) x_to_y(x, z)
g(3)
z <- 4
g(3)
g
z <- NULL
g(5)
```
```{r}
#| eval: false
rm(z)
g(6) ## does not work any more as z does not exist any more
```

